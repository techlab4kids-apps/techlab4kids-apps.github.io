(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["addon-entry-paint-skew"],{

/***/ "./src/addons/addons/paint-skew/_runtime_entry.js":
/*!********************************************************!*\
  !*** ./src/addons/addons/paint-skew/_runtime_entry.js ***!
  \********************************************************/
/*! exports provided: resources */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resources", function() { return resources; });
/* harmony import */ var _userscript_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userscript.js */ "./src/addons/addons/paint-skew/userscript.js");
/* generated by pull.js */

const resources = {
  "userscript.js": _userscript_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};

/***/ }),

/***/ "./src/addons/addons/paint-skew/userscript.js":
/*!****************************************************!*\
  !*** ./src/addons/addons/paint-skew/userscript.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable require-jsdoc */
/* harmony default export */ __webpack_exports__["default"] = (async function (_ref) {
  let {
    addon
  } = _ref;
  const paper = await addon.tab.traps.getPaper();
  const addSkew = function addSkew() {
    if (!paper.tool || !paper.tool.boundingBoxTool) return;
    const ST = paper.tool.boundingBoxTool._modeMap.SCALE.constructor;
    if (!ST) {
      return;
    }
    if (ST.hasSkew) {
      return;
    }
    ST.hasSkew = true;
    const ogMouseDown = ST.prototype.onMouseDown;
    ST.prototype.onMouseDown = function (hitResult, boundsPath, selectedItems) {
      if (this.active) return;
      this.index = hitResult.item.data.index;
      ogMouseDown.call(this, hitResult, boundsPath, selectedItems);
      this.isSkew = false;
      this.skewCenter = false;
      this.lastSkx = 0;
      this.lastSky = 0;
      this.skewBounds = this.itemGroup.bounds.clone();
    };
    const ogMouseDrag = ST.prototype.onMouseDrag;
    ST.prototype.onMouseDrag = function (event) {
      if (!this.active) return;
      if (addon.self.disabled) return ogMouseDrag.call(this, event);
      const bounds = this.skewBounds;
      const doShear = (skx, sky) => {
        if (skx === 0 && sky === 0) return;
        let offcenterPosition;
        if (!this.skewCenter) {
          switch (this._getRectCornerNameByIndex(this.index)) {
            case 'topCenter':
            case 'leftCenter':
              offcenterPosition = this.itemGroup.position.add(new paper.Point(bounds.width / 2, bounds.height / 2));
              break;
            case 'bottomCenter':
            case 'rightCenter':
              offcenterPosition = this.itemGroup.position.subtract(new paper.Point(bounds.width / 2, bounds.height / 2));
              break;
          }
        }
        const position = this.skewCenter ? this.itemGroup.position : offcenterPosition;
        const shearMult = this.skewCenter ? 2 : 1;
        // swap width and height because apparently
        // shearing is based on the dimension perpendicular
        // to the one that is being skewed
        const shearX = skx / bounds.height * shearMult;
        const shearY = sky / bounds.width * shearMult;
        this.itemGroup.shear(shearX, shearY, position);
        if (this.selectionAnchor) {
          this.selectionAnchor.shear(-shearX, -shearY);
        }
      };

      // Revert skew
      doShear(-this.lastSkx, -this.lastSky);
      this.skewCenter = event.modifiers.alt;
      let skx = 0;
      let sky = 0;
      this.lastSkx = 0;
      this.lastSky = 0;
      if (event.modifiers.control && !this.isCorner) {
        // Skew
        if (this.isSkew === false) {
          // Reset position
          this.centered = false;
          this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);
          if (this.selectionAnchor) {
            this.selectionAnchor.scale(this.lastSx, this.lastSy);
          }
          this.lastSx = 1;
          this.lastSy = 1;
        }
        const delta = event.point.subtract(this.pivot);
        switch (this._getRectCornerNameByIndex(this.index)) {
          case 'topCenter':
            delta.x *= -1;
            delta.y = 0;
            break;
          case 'bottomCenter':
            delta.y = 0;
            break;
          case 'leftCenter':
            delta.y *= -1;
            delta.x = 0;
            break;
          case 'rightCenter':
            delta.x = 0;
            break;
          default:
            delta.x = 0;
            delta.y = 0;
        }
        skx = delta.x;
        sky = delta.y;
        doShear(skx, sky);
      } else {
        // Scale
        ogMouseDrag.call(this, event);
      }
      this.lastSkx = skx;
      this.lastSky = sky;
    };
  };
  addon.tab.redux.initialize();
  addon.tab.redux.addEventListener('statechanged', e => {
    const action = e.detail.action;
    if (action.type === 'scratch-paint/modes/CHANGE_MODE' && (action.mode === 'BIT_SELECT' || action.mode === 'SELECT')) {
      addSkew();
    }
  });
  addSkew();
});

/***/ })

}]);
//# sourceMappingURL=addon-entry-paint-skew.js.map