{"version":3,"file":"js/addon-entry-paint-skew.js","sources":["webpack://GUI/./src/addons/addons/paint-skew/_runtime_entry.js","webpack://GUI/./src/addons/addons/paint-skew/userscript.js"],"sourcesContent":["/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","/* eslint-disable require-jsdoc */\nexport default async function ({addon}) {\n    const paper = await addon.tab.traps.getPaper();\n\n    const addSkew = function () {\n        if (!paper.tool || !paper.tool.boundingBoxTool) return;\n        const ST = paper.tool.boundingBoxTool._modeMap.SCALE.constructor;\n        if (!ST) {\n            return;\n        }\n        if (ST.hasSkew) {\n            return;\n        }\n        ST.hasSkew = true;\n\n        const ogMouseDown = ST.prototype.onMouseDown;\n        ST.prototype.onMouseDown = function (hitResult, boundsPath, selectedItems) {\n            if (this.active) return;\n            this.index = hitResult.item.data.index;\n            ogMouseDown.call(this, hitResult, boundsPath, selectedItems);\n            this.isSkew = false;\n            this.skewCenter = false;\n            this.lastSkx = 0;\n            this.lastSky = 0;\n            this.skewBounds = this.itemGroup.bounds.clone();\n        };\n\n        const ogMouseDrag = ST.prototype.onMouseDrag;\n        ST.prototype.onMouseDrag = function (event) {\n            if (!this.active) return;\n            if (addon.self.disabled) return ogMouseDrag.call(this, event);\n\n            const bounds = this.skewBounds;\n            const doShear = (skx, sky) => {\n                if (skx === 0 && sky === 0) return;\n\n                let offcenterPosition;\n                if (!this.skewCenter) {\n                    switch (this._getRectCornerNameByIndex(this.index)) {\n                    case 'topCenter':\n                    case 'leftCenter':\n                        offcenterPosition = this.itemGroup.position.add(new paper.Point(bounds.width / 2, bounds.height / 2));\n                        break;\n                    case 'bottomCenter':\n                    case 'rightCenter':\n                        offcenterPosition = this.itemGroup.position.subtract(\n                            new paper.Point(bounds.width / 2, bounds.height / 2)\n                        );\n                        break;\n                    }\n                }\n\n                const position = this.skewCenter ? this.itemGroup.position : offcenterPosition;\n\n                const shearMult = this.skewCenter ? 2 : 1;\n                // swap width and height because apparently\n                // shearing is based on the dimension perpendicular\n                // to the one that is being skewed\n                const shearX = (skx / bounds.height) * shearMult;\n                const shearY = (sky / bounds.width) * shearMult;\n\n                this.itemGroup.shear(shearX, shearY, position);\n                if (this.selectionAnchor) {\n                    this.selectionAnchor.shear(-shearX, -shearY);\n                }\n            };\n\n            // Revert skew\n            doShear(-this.lastSkx, -this.lastSky);\n\n            this.skewCenter = event.modifiers.alt;\n\n            let skx = 0;\n            let sky = 0;\n            this.lastSkx = 0;\n            this.lastSky = 0;\n\n            if (event.modifiers.control && !this.isCorner) {\n                // Skew\n                if (this.isSkew === false) {\n                    // Reset position\n                    this.centered = false;\n                    this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);\n                    if (this.selectionAnchor) {\n                        this.selectionAnchor.scale(this.lastSx, this.lastSy);\n                    }\n                    this.lastSx = 1;\n                    this.lastSy = 1;\n                }\n\n                const delta = event.point.subtract(this.pivot);\n                switch (this._getRectCornerNameByIndex(this.index)) {\n                case 'topCenter':\n                    delta.x *= -1;\n                    delta.y = 0;\n                    break;\n                case 'bottomCenter':\n                    delta.y = 0;\n                    break;\n                case 'leftCenter':\n                    delta.y *= -1;\n                    delta.x = 0;\n                    break;\n                case 'rightCenter':\n                    delta.x = 0;\n                    break;\n                default:\n                    delta.x = 0;\n                    delta.y = 0;\n                }\n                skx = delta.x;\n                sky = delta.y;\n\n                doShear(skx, sky);\n            } else {\n                // Scale\n                ogMouseDrag.call(this, event);\n            }\n            this.lastSkx = skx;\n            this.lastSky = sky;\n        };\n    };\n\n    addon.tab.redux.initialize();\n    addon.tab.redux.addEventListener('statechanged', e => {\n        const action = e.detail.action;\n        if (\n            action.type === 'scratch-paint/modes/CHANGE_MODE' &&\n      (action.mode === 'BIT_SELECT' || action.mode === 'SELECT')\n        ) {\n            addSkew();\n        }\n    });\n    addSkew();\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}